<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>圣诞树 - 国内极速版</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    #debug_console {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #00ff00;
      background: rgba(0, 0, 0, 0.8);
      padding: 8px;
      font-size: 12px;
      font-family: monospace;
      z-index: 999;
      pointer-events: none;
      max-width: 90%;
      white-space: pre-wrap;
      border: 1px solid #00ff00;
      border-radius: 4px;
    }
    #input_video {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 100px;
      height: auto;
      z-index: 998;
      opacity: 0.6;
      transform: scaleX(-1);
      display: block; /* 确保可见以便调试 */
    }
  </style>

  <script>
    window.logError = function(msg) {
      const el = document.getElementById('debug_console');
      if(el) el.innerText += '\n[错误] ' + msg;
      console.error(msg);
    }
    window.logInfo = function(msg) {
      const el = document.getElementById('debug_console');
      if(el) el.innerText = msg;
      console.log(msg);
    }
    window.appendLog = function(msg) {
        const el = document.getElementById('debug_console');
        if(el) el.innerText += '\n' + msg;
    }
  </script>

  <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous" onerror="window.logError('camera_utils 加载失败')"></script>
  <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous" onerror="window.logError('control_utils 加载失败')"></script>
  <script src="https://npm.elemecdn.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous" onerror="window.logError('drawing_utils 加载失败')"></script>
  <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js" crossorigin="anonymous" onerror="window.logError('hands.js 加载失败! 请检查网络')"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://npm.elemecdn.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://npm.elemecdn.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="debug_console">正在连接国内镜像源...\n若10秒无反应，请刷新重试</div>
  <video id="input_video" playsinline webkit-playsinline></video>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

    // ================= 1. 核心布局数据 =================
    const FIXED_LAYOUT = [
      { "name": "giftbox4.glb", "pos": [10.33, -32, 59.09], "rot": 1.66 }, { "name": "giftbox1.glb", "pos": [21.06, -32, -2.97], "rot": 1.06 }, { "name": "giftbox3.glb", "pos": [10.07, -32, 39.08], "rot": 2.33 }, { "name": "giftbox3.glb", "pos": [6.9, -32, 63.75], "rot": 1.26 }, { "name": "giftbox2.glb", "pos": [23.1, -32, 48.07], "rot": 1.23 }, { "name": "giftbox1.glb", "pos": [18.68, -32, 0.85], "rot": 3.13 }, { "name": "giftbox4.glb", "pos": [1, -32, 13.04], "rot": 1.58 }, { "name": "giftbox1.glb", "pos": [-10.65, -32, -14.06], "rot": 0.05 }, { "name": "giftbox4.glb", "pos": [30.9, -32, 12.76], "rot": 1.51 }, { "name": "giftbox5.glb", "pos": [-16.37, -32, 66.98], "rot": 0.73 }, { "name": "giftbox2.glb", "pos": [-44.31, -32, 52.75], "rot": 0.14 }, { "name": "giftbox1.glb", "pos": [4.98, -32, 6.17], "rot": 1.06 }, { "name": "giftbox4.glb", "pos": [3.07, -32, 39.17], "rot": 0.33 }, { "name": "giftbox5.glb", "pos": [22.66, -32, 50.69], "rot": 2.3 }, { "name": "giftbox2.glb", "pos": [19.69, -32, -18.06], "rot": 2.8 }, { "name": "giftbox3.glb", "pos": [39.87, -32, 22.91], "rot": 1.87 }, { "name": "giftbox4.glb", "pos": [-25.88, -32, 43.69], "rot": 1.18 }, { "name": "giftbox2.glb", "pos": [33.85, -32, -3.28], "rot": 2.15 }, { "name": "giftbox2.glb", "pos": [18.23, -32, 22.29], "rot": 1.63 }
    ];

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.environment = scene.background;
    scene.fog = new THREE.FogExp2(0x000000, 0.0015);

    const treeRoot = new THREE.Group();
    scene.add(treeRoot);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2.0);
    hemiLight.position.set(0, 50, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    const cameraLight = new THREE.PointLight(0xffffff, 1.5);
    cameraLight.position.set(5, 5, 5);
    camera.add(cameraLight);
    scene.add(camera);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.useLegacyLights = false;
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05; controls.autoRotate = false;
    controls.minDistance = 1; controls.maxDistance = 1000; controls.target.set(0, 5, 0);

    // Globals
    const floatingObjects = [];
    const lightBulbs = []; 
    let isExploded = false;
    const isMobile = window.innerWidth < 768;
    let isCameraMoving = false;
    let targetCameraPos = new THREE.Vector3();
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let activeUUID = null;
    let isInspectionDragging = false;
    const previousMouse = new THREE.Vector2();
    let initialPinchDistance = 0;
    let initialScale = 0;
    let lastTapTime = 0;
    let touchStartTime = 0;
    let isMultiTouch = false;
    let isDragMove = false;
    const touchStartPos = new THREE.Vector2();
    let fireworks = [];
    let lastGesture = 'UNKNOWN';
    const tmpV3a = new THREE.Vector3(); const tmpV3b = new THREE.Vector3(); const tmpV3c = new THREE.Vector3(); const tmpBox = new THREE.Box3();

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function findInteractiveRoot(obj) { let cur = obj; while (cur && cur !== scene) { if (cur.userData && cur.userData.isInteractive) return cur; cur = cur.parent; } return null; }
    function faceCameraUprightY(obj) { obj.getWorldPosition(tmpV3a); camera.getWorldPosition(tmpV3b); const dx = tmpV3b.x - tmpV3a.x; const dz = tmpV3b.z - tmpV3a.z; const yaw = Math.atan2(dx, dz); obj.rotation.x = 0; obj.rotation.z = 0; obj.rotation.y = yaw; }
    function getFocusPosByDistance(dist) { const focusPos = new THREE.Vector3(); camera.getWorldDirection(focusPos).multiplyScalar(dist).add(camera.position); return focusPos; }
    function computeSafeDistance(radiusWorld) { const vFov = THREE.MathUtils.degToRad(camera.fov); const hFov = 2 * Math.atan(Math.tan(vFov / 2) * camera.aspect); const minHalfFov = Math.min(vFov, hFov) / 2; const margin = 2.0; const dist = (radiusWorld * margin) / Math.tan(minHalfFov); return dist + radiusWorld * 0.8; }
    function alignLocalCenterToWorldPoint(obj, localCenter, worldTarget) { const worldCenterNow = obj.localToWorld(localCenter.clone()); const delta = worldTarget.clone().sub(worldCenterNow); obj.position.add(delta); }
    function getWorldRadius(obj) { tmpBox.setFromObject(obj); const size = tmpBox.getSize(tmpV3c); let r = 0.5 * Math.sqrt(size.x * size.x + size.y * size.y + size.z * size.z); r = clamp(r, 2.0, 40.0); return r; }
    function getTreeTopWorldPoint(out = new THREE.Vector3()) { const box = new THREE.Box3(); let has = false; for (const obj of floatingObjects) { if (!obj.userData) continue; if (obj.userData.pickType === 'gift') continue; if (obj.userData.isTreeTop) continue; box.expandByObject(obj); has = true; } if (!has) { out.set(controls.target.x, 30, controls.target.z); return out; } const topY = box.max.y; const centerX = (box.min.x + box.max.x) / 2; const centerZ = (box.min.z + box.max.z) / 2; out.set(centerX, topY, centerZ); return out; }
    function snapBottomCenterToWorldPoint(obj, worldPoint) { const local = obj.userData.bottomCenterLocal; if (!local) return; const worldNow = obj.localToWorld(local.clone()); const delta = worldPoint.clone().sub(worldNow); obj.position.add(delta); }

    function createGlowTexture() { const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32; const ctx = canvas.getContext('2d'); const g = ctx.createRadialGradient(16, 16, 0, 16, 16, 16); g.addColorStop(0, 'rgba(255,255,255,1)'); g.addColorStop(1, 'rgba(255,255,255,0)'); ctx.fillStyle = g; ctx.fillRect(0, 0, 32, 32); const t = new THREE.CanvasTexture(canvas); t.colorSpace = THREE.SRGBColorSpace; return t; }
    const starsCount = 1500; const starsPos = new Float32Array(starsCount * 3); const starsColors = new Float32Array(starsCount * 3); const colorObj = new THREE.Color();
    for (let i = 0; i < starsCount * 3; i++) starsPos[i] = (Math.random() - 0.5) * 1500;
    for (let i = 0; i < starsCount; i++) { const tone = Math.random(); if (tone > 0.8) colorObj.setHex(0xffd700); else if (tone > 0.5) colorObj.setHex(0x88ccff); else colorObj.setHex(0xffffff); starsColors[i * 3
