<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>圣诞树 - 赛博手势版</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    
    /* 调试文字 */
    #debug_console {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #00ff00;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px;
      font-size: 12px;
      font-family: monospace;
      z-index: 999;
      pointer-events: none;
      max-width: 90%;
      white-space: pre-wrap;
      border: 1px solid #00ff00;
      border-radius: 4px;
    }

    /* 摄像头悬浮窗容器 */
    #camera_container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 120px;
      height: 160px; /* 4:3 比例 */
      z-index: 1000;
      /* 科技感边框 */
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.5);
      overflow: hidden;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
      /* 允许点击操作 */
      touch-action: none; 
    }

    /* 画布：用于显示视频和绘制骨骼 */
    #output_canvas {
      width: 100%;
      height: 100%;
      transform: scaleX(-1); /* 镜像翻转，像照镜子 */
      display: block;
    }

    /* 原始视频隐藏，只用于后台识别 */
    #input_video {
      display: none;
    }
  </style>

  <script>
    window.logError = function(msg) {
      const el = document.getElementById('debug_console');
      if(el) el.innerText += '\n[错误] ' + msg;
      console.error(msg);
    }
    window.logInfo = function(msg) {
      const el = document.getElementById('debug_console');
      if(el) el.innerText = msg;
      console.log(msg);
    }
    window.appendLog = function(msg) {
        const el = document.getElementById('debug_console');
        if(el) el.innerText += '\n' + msg;
    }
  </script>

  <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous" onerror="window.logError('camera_utils 加载失败')"></script>
  <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous" onerror="window.logError('control_utils 加载失败')"></script>
  <script src="https://npm.elemecdn.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous" onerror="window.logError('drawing_utils 加载失败')"></script>
  <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js" crossorigin="anonymous" onerror="window.logError('hands.js 加载失败')"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://npm.elemecdn.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://npm.elemecdn.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="debug_console">系统初始化中...</div>
  
  <div id="camera_container">
      <canvas id="output_canvas"></canvas>
  </div>
  <video id="input_video" playsinline webkit-playsinline></video>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

    // ================= 1. 核心布局数据 =================
    const FIXED_LAYOUT = [
      { "name": "giftbox4.glb", "pos": [10.33, -32, 59.09], "rot": 1.66 }, { "name": "giftbox1.glb", "pos": [21.06, -32, -2.97], "rot": 1.06 }, { "name": "giftbox3.glb", "pos": [10.07, -32, 39.08], "rot": 2.33 }, { "name": "giftbox3.glb", "pos": [6.9, -32, 63.75], "rot": 1.26 }, { "name": "giftbox2.glb", "pos": [23.1, -32, 48.07], "rot": 1.23 }, { "name": "giftbox1.glb", "pos": [18.68, -32, 0.85], "rot": 3.13 }, { "name": "giftbox4.glb", "pos": [1, -32, 13.04], "rot": 1.58 }, { "name": "giftbox1.glb", "pos": [-10.65, -32, -14.06], "rot": 0.05 }, { "name": "giftbox4.glb", "pos": [30.9, -32, 12.76], "rot": 1.51 }, { "name": "giftbox5.glb", "pos": [-16.37, -32, 66.98], "rot": 0.73 }, { "name": "giftbox2.glb", "pos": [-44.31, -32, 52.75], "rot": 0.14 }, { "name": "giftbox1.glb", "pos": [4.98, -32, 6.17], "rot": 1.06 }, { "name": "giftbox4.glb", "pos": [3.07, -32, 39.17], "rot": 0.33 }, { "name": "giftbox5.glb", "pos": [22.66, -32, 50.69], "rot": 2.3 }, { "name": "giftbox2.glb", "pos": [19.69, -32, -18.06], "rot": 2.8 }, { "name": "giftbox3.glb", "pos": [39.87, -32, 22.91], "rot": 1.87 }, { "name": "giftbox4.glb", "pos": [-25.88, -32, 43.69], "rot": 1.18 }, { "name": "giftbox2.glb", "pos": [33.85, -32, -3.28], "rot": 2.15 }, { "name": "giftbox2.glb", "pos": [18.23, -32, 22.29], "rot": 1.63 }
    ];

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.environment = scene.background;
    scene.fog = new THREE.FogExp2(0x000000, 0.0015);

    const treeRoot = new THREE.Group();
    scene.add(treeRoot);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2.0);
    hemiLight.position.set(0, 50, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    const cameraLight = new THREE.PointLight(0xffffff, 1.5);
    cameraLight.position.set(5, 5, 5);
    camera.add(cameraLight);
    scene.add(camera);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.useLegacyLights = false;
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05; controls.autoRotate = false;
    controls.minDistance = 1; controls.maxDistance = 1000; controls.target.set(0, 5, 0);

    // Globals
    const floatingObjects = [];
    const lightBulbs = []; 
    let isExploded = false;
    const isMobile = window.innerWidth < 768;
    let isCameraMoving = false;
    let targetCameraPos = new THREE.Vector3();
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let activeUUID = null;
    let isInspectionDragging = false;
    const previousMouse = new THREE.Vector2();
    let initialPinchDistance = 0;
    let initialScale = 0;
    let lastTapTime = 0;
    let touchStartTime = 0;
    let isMultiTouch = false;
    let isDragMove = false;
    const touchStartPos = new THREE.Vector2();
    let fireworks = [];
    let lastGesture = 'UNKNOWN';
    const tmpV3a = new THREE.Vector3(); const tmpV3b = new THREE.Vector3(); const tmpV3c = new THREE.Vector3(); const tmpBox = new THREE.Box3();

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function findInteractiveRoot(obj) { let cur = obj; while (cur && cur !== scene) { if (cur.userData && cur.userData.isInteractive) return cur; cur = cur.parent; } return null; }
    function faceCameraUprightY(obj) { obj.getWorldPosition(tmpV3a); camera.getWorldPosition(tmpV3b); const dx = tmpV3b.x - tmpV3a.x; const dz = tmpV3b.z - tmpV3a.z; const yaw = Math.atan2(dx, dz); obj.rotation.x = 0; obj.rotation.z = 0; obj.rotation.y = yaw; }
    function getFocusPosByDistance(dist) { const focusPos = new THREE.Vector3(); camera.getWorldDirection(focusPos).multiplyScalar(dist).add(camera.position); return focusPos; }
    function computeSafeDistance(radiusWorld) { const vFov = THREE.MathUtils.degToRad(camera.fov); const hFov = 2 * Math.atan(Math.tan(vFov / 2) * camera.aspect); const minHalfFov = Math.min(vFov, hFov) / 2; const margin = 2.0; const dist = (radiusWorld * margin) / Math.tan(minHalfFov); return dist + radiusWorld * 0.8; }
    function alignLocalCenterToWorldPoint(obj, localCenter, worldTarget) { const worldCenterNow = obj.localToWorld(localCenter.clone()); const delta = worldTarget.clone().sub(worldCenterNow); obj.position.add(delta); }
    function getWorldRadius(obj) { tmpBox.setFromObject(obj); const size = tmpBox.getSize(tmpV3c); let r = 0.5 * Math.sqrt(size.x * size.x + size.y * size.y + size.z * size.z); r = clamp(r, 2.0, 40.0); return r; }
    function getTreeTopWorldPoint(out = new THREE.Vector3()) { const box = new THREE.Box3(); let has = false; for (const obj of floatingObjects) { if (!obj.userData) continue; if (obj.userData.pickType === 'gift') continue; if (obj.userData.isTreeTop) continue; box.expandByObject(obj); has = true; } if (!has) { out.set(controls.target.x, 30, controls.target.z); return out; } const topY = box.max.y; const centerX = (box.min.x + box.max.x) / 2; const centerZ = (box.min.z + box.max.z) / 2; out.set(centerX, topY, centerZ); return out; }
    function snapBottomCenterToWorldPoint(obj, worldPoint) { const local = obj.userData.bottomCenterLocal; if (!local) return; const worldNow = obj.localToWorld(local.clone()); const delta = worldPoint.clone().sub(worldNow); obj.position.add(delta); }

    function createGlowTexture() { const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32; const ctx = canvas.getContext('2d'); const g = ctx.createRadialGradient(16, 16, 0, 16, 16, 16); g.addColorStop(0, 'rgba(255,255,255,1)'); g.addColorStop(1, 'rgba(255,255,255,0)'); ctx.fillStyle = g; ctx.fillRect(0, 0, 32, 32); const t = new THREE.CanvasTexture(canvas); t.colorSpace = THREE.SRGBColorSpace; return t; }
    const starsCount = 1500; const starsPos = new Float32Array(starsCount * 3); const starsColors = new Float32Array(starsCount * 3); const colorObj = new THREE.Color();
    for (let i = 0; i < starsCount * 3; i++) starsPos[i] = (Math.random() - 0.5) * 1500;
    for (let i = 0; i < starsCount; i++) { const tone = Math.random(); if (tone > 0.8) colorObj.setHex(0xffd700); else if (tone > 0.5) colorObj.setHex(0x88ccff); else colorObj.setHex(0xffffff); starsColors[i * 3] = colorObj.r; starsColors[i * 3 + 1] = colorObj.g; starsColors[i * 3 + 2] = colorObj.b; }
    const starGeo = new THREE.BufferGeometry(); starGeo.setAttribute('position', new THREE.BufferAttribute(starsPos, 3)); starGeo.setAttribute('color', new THREE.BufferAttribute(starsColors, 3));
    const starMat = new THREE.PointsMaterial({ size: 2.5, map: createGlowTexture(), vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
    const starMesh = new THREE.Points(starGeo, starMat); scene.add(starMesh);

    const TOTAL_LEAVES = 600; const TREE_HEIGHT = 60; const TREE_RADIUS = 20;
    const photoFiles = []; for (let i = 0; i <= 61; i++) photoFiles.push(i === 0 ? 'photos/A.jpg' : `photos/A (${i}).jpg`);
    const leafList = [...photoFiles]; while (leafList.length < TOTAL_LEAVES) leafList.push(photoFiles[Math.floor(Math.random() * photoFiles.length)]); leafList.sort(() => Math.random() - 0.5);

    function loadCompressedTexture(url, callback) { const image = new Image(); image.src = url; image.crossOrigin = "Anonymous"; image.onload = () => { const canvas = document.createElement('canvas'); const maxSize = 256; let width = image.width; let height = image.height; if (width > height) { if (width > maxSize) { height *= maxSize / width; width = maxSize; } } else { if (height > maxSize) { width *= maxSize / height; height = maxSize; } } canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.drawImage(image, 0, 0, width, height); const texture = new THREE.CanvasTexture(canvas); texture.colorSpace = THREE.SRGBColorSpace; callback(texture); }; }
    function setupOrbitalData(mesh, scaleFactor) {
      mesh.userData.originPos = mesh.position.clone(); mesh.userData.originRot = mesh.rotation.clone(); mesh.userData.originScale = mesh.scale.clone();
      mesh.userData.orbitRadius = (isMobile ? 100 : 120) + Math.random() * 100; mesh.userData.orbitY = (Math.random() - 0.5) * 120; mesh.userData.orbitAngle = Math.random() * Math.PI * 2; mesh.userData.orbitSpeed = 0.001 + Math.random() * 0.002;
      mesh.userData.explodedScale = mesh.scale.clone().multiplyScalar(scaleFactor); mesh.userData.isExplodedVisible = mesh.type === 'Group' ? true : (Math.random() < 0.25);
      mesh.userData.floatSpeed = { x: (Math.random() - 0.5) * 0.01, y: (Math.random() - 0.5) * 0.01, z: 0 }; mesh.userData.isInteractive = true; mesh.userData.pinned = false; mesh.userData.pinnedDist = null;
      mesh.userData.pinnedRot = new THREE.Euler(0, 0, 0); mesh.userData.localCenter = new THREE.Vector3(0, 0, 0); mesh.userData.inspectionPos = new THREE.Vector3(); mesh.userData.inspectionBaseScale = 3.0; mesh.userData.currentInspectionScale = 3.0;
      mesh.userData.pickType = (mesh.type === 'Group') ? 'gift' : (mesh.geometry && mesh.geometry.type === 'PlaneGeometry') ? 'photo' : 'other'; mesh.userData.isTreeTop = false; mesh.userData.bottomCenterLocal = null; mesh.userData.yawOffset = 0; mesh.userData.treeFacingSet = false;
      floatingObjects.push(mesh);
    }

    leafList.forEach((file, i) => { loadCompressedTexture(file, (texture) => { const imgAspect = texture.image.width / texture.image.height; const baseSize = 3; let w = imgAspect > 1 ? baseSize * imgAspect : baseSize; let h = imgAspect > 1 ? baseSize : baseSize / imgAspect; const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true })); const h_norm = Math.pow(i / TOTAL_LEAVES, 0.5); const y = (TREE_HEIGHT / 2) - (h_norm * TREE_HEIGHT); const r = (TREE_RADIUS * h_norm) + (Math.random() * 5); const theta = Math.random() * Math.PI * 2; mesh.position.set(r * Math.cos(theta), y, r * Math.sin(theta)); mesh.lookAt(0, y, 0); mesh.rotateX(-Math.PI / 2); mesh.rotateX(-(Math.random() * 0.5 + 0.3)); mesh.rotateY((Math.random() - 0.5) * 0.5); mesh.rotateZ(Math.PI + (Math.random() - 0.5) * 0.5); setupOrbitalData(mesh, 3.0); mesh.userData.inspectionBaseScale = 1.5; mesh.userData.currentInspectionScale = 1.5; mesh.userData.localCenter.set(0, 0, 0); treeRoot.add(mesh); }); });

    const colors = [0xDC143C, 0xFFD700, 0x228B22, 0xE0E0E0];
    const baseSphereGeo = new THREE.SphereGeometry(0.3, 32, 32); const sphereCount = 450;
    for (let i = 0; i < sphereCount; i++) { const sphere = new THREE.Mesh(baseSphereGeo, new THREE.MeshStandardMaterial({ color: colors[Math.floor(Math.random() * colors.length)], metalness: 0.7, roughness: 0.35, envMapIntensity: 1.0 })); const scale = Math.random() * 1.2 + 0.8; sphere.scale.set(scale, scale, scale); const h_norm = Math.pow(i / sphereCount, 0.7); const y = (TREE_HEIGHT / 2) - (h_norm * TREE_HEIGHT); const r = (TREE_RADIUS * h_norm) + (Math.random() - 0.5) * 4; const theta = Math.random() * Math.PI * 2; sphere.position.set(r * Math.cos(theta), y, r * Math.sin(theta)); setupOrbitalData(sphere, 2.5); sphere.userData.localCenter.set(0, 0, 0); treeRoot.add(sphere); }

    const gltfLoader = new GLTFLoader();
    function loadClawhauserGLB(url) { gltfLoader.load(url, (gltf) => { const model = gltf.scene; const root = new THREE.Group(); root.add(model); model.scale.set(10, 10, 10); model.rotation.set(-THREE.MathUtils.degToRad(20), 0, Math.PI / 2); model.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } }); root.position.set(0, TREE_HEIGHT / 2, 0); setupOrbitalData(root, 2.0); root.userData.isExplodedVisible = true; root.userData.isTreeTop = true; root.userData.yawOffset = -THREE.MathUtils.degToRad(18); root.userData.orbitRadius = 80; root.userData.orbitY = TREE_HEIGHT / 2 + 10; root.userData.treeFacingSet = false; treeRoot.add(root); scene.updateMatrixWorld(true); const b = new THREE.Box3().setFromObject(root); const center = new THREE.Vector3(); b.getCenter(center); const bottomCenterWorld = new THREE.Vector3((b.min.x + b.max.x) / 2, b.min.y, (b.min.z + b.max.z) / 2); root.userData.bottomCenterLocal = root.worldToLocal(bottomCenterWorld.clone()); const localCenter = root.worldToLocal(center.clone()); root.userData.localCenter.copy(localCenter); }, undefined, (err) => console.log("GLB error", err)); }
    loadClawhauserGLB('clawhauser.glb');

    const giftFiles = ['giftbox1.glb', 'giftbox2.glb', 'giftbox3.glb', 'giftbox4.glb', 'giftbox5.glb']; const loadedModels = {}; let loadCount = 0;
    giftFiles.forEach(fileName => { gltfLoader.load(fileName, (gltf) => { loadedModels[fileName] = gltf.scene; checkLoadFinish(); }, undefined, () => { console.warn(fileName + " 加载失败"); checkLoadFinish(); }); });
    function checkLoadFinish() { loadCount++; if (loadCount === giftFiles.length) spawnFixedBoxes(); }
    function spawnFixedBoxes() { FIXED_LAYOUT.forEach(data => { const template = loadedModels[data.name]; if (!template) return; const clone = template.clone(true); clone.scale.set(15.0, 15.0, 15.0); const box3 = new THREE.Box3().setFromObject(clone); const yOffset = -box3.min.y; const group = new THREE.Group(); clone.position.y = yOffset; group.add(clone); group.position.set(data.pos[0], data.pos[1], data.pos[2]); group.rotation.y = data.rot; group.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } }); scene.add(group); setupOrbitalData(group, 1.5); group.userData.orbitY = (Math.random() - 0.5) * 40 - 40; group.userData.isExplodedVisible = true; group.userData.pickType = 'gift'; const localCenter = box3.getCenter(new THREE.Vector3()); localCenter.y += yOffset; group.userData.localCenter.copy(localCenter); }); }

    function createLightStrip() { const lightStripGroup = new THREE.Group(); const stripBottomY = -TREE_HEIGHT / 2 + 2; const stripTopY = TREE_HEIGHT / 2 - 5; const stripHeight = stripTopY - stripBottomY; const radiusBottom = TREE_RADIUS + 2; const radiusTop = 4; const turns = 6; const lightCount = 250; const bulbGeo = new THREE.SphereGeometry(isMobile ? 0.1 : 0.15, 8, 8); for (let i = 0; i < lightCount; i++) { const t = i / (lightCount - 1); const angle = t * turns * Math.PI * 2; const currentRadius = radiusBottom * (1 - t) + radiusTop * t; const y = stripBottomY + t * stripHeight; const x = Math.cos(angle) * currentRadius; const z = Math.sin(angle) * currentRadius; const bulbMat = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 2.0, roughness: 0.3 }); const bulb = new THREE.Mesh(bulbGeo, bulbMat); bulb.position.set(x, y, z); bulb.userData.blinkSpeed = 0.01 + Math.random() * 0.02; bulb.userData.blinkOffset = Math.random() * 100; lightStripGroup.add(bulb); lightBulbs.push(bulb); } const mainLight = new THREE.PointLight(0xffaa33, 2.0, 80); mainLight.position.set(0, 0, 0); lightStripGroup.add(mainLight); treeRoot.add(lightStripGroup); setupOrbitalData(lightStripGroup, 0.0001); lightStripGroup.userData.isExplodedVisible = false; lightStripGroup.userData.pickType = 'other'; lightStripGroup.userData.localCenter.set(0, 0, 0); }
    createLightStrip();

    function createFirework() { const particleCount = isMobile ? 100 : 200; const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(particleCount * 3); const colors = new Float32Array(particleCount * 3); const velocities = []; const fireworkColor = new THREE.Color(); fireworkColor.setHSL(Math.random(), 1.0, 0.5); for (let i = 0; i < particleCount; i++) { positions[i * 3] = 0; positions[i * 3 + 1] = TREE_HEIGHT / 2 + 20; positions[i * 3 + 2] = 0; colors[i * 3] = fireworkColor.r; colors[i * 3 + 1] = fireworkColor.g; colors[i * 3 + 2] = fireworkColor.b; const velocity = new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2); velocity.normalize().multiplyScalar(Math.random() * 2 + 1); velocities.push(velocity); } geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); const particleMaterial = new THREE.PointsMaterial({ size: 1.5, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 1.0, map: createGlowTexture(), depthWrite: false }); const particleSystem = new THREE.Points(geometry, particleMaterial); particleSystem.userData.velocities = velocities; particleSystem.userData.life = 1.0; scene.add(particleSystem); fireworks.push(particleSystem); }
    function updateFireworks() { for (let i = fireworks.length - 1; i >= 0; i--) { const firework = fireworks[i]; const positions = firework.geometry.attributes.position.array; const velocities = firework.userData.velocities; firework.userData.life -= 0.015; firework.material.opacity = firework.userData.life; for (let j = 0; j < velocities.length; j++) { velocities[j].y -= 0.03; positions[j * 3] += velocities[j].x; positions[j * 3 + 1] += velocities[j].y; positions[j * 3 + 2] += velocities[j].z; } firework.geometry.attributes.position.needsUpdate = true; if (firework.userData.life <= 0) { scene.remove(firework); firework.geometry.dispose(); firework.material.dispose(); fireworks.splice(i, 1); } } }

    const videoElement = document.getElementById('input_video');
    const outputCanvas = document.getElementById('output_canvas');
    const canvasCtx = outputCanvas.getContext('2d');
    
    // ================= 悬浮窗拖拽逻辑 =================
    const cameraContainer = document.getElementById('camera_container');
    let dragStartX = 0;
    let dragStartY = 0;
    let initialLeft = 0;
    let initialTop = 0;
    let isDraggingContainer = false;

    cameraContainer.addEventListener('touchstart', (e) => {
        isDraggingContainer = true;
        dragStartX = e.touches[0].clientX;
        dragStartY = e.touches[0].clientY;
        const rect = cameraContainer.getBoundingClientRect();
        initialLeft = rect.left;
        initialTop = rect.top;
        e.stopPropagation(); // 阻止事件传给 Three.js 场景
    }, { passive: false });

    cameraContainer.addEventListener('touchmove', (e) => {
        if (!isDraggingContainer) return;
        e.preventDefault(); // 阻止页面滚动
        const deltaX = e.touches[0].clientX - dragStartX;
        const deltaY = e.touches[0].clientY - dragStartY;
        // 限制在屏幕范围内
        let newLeft = initialLeft + deltaX;
        let newTop = initialTop + deltaY;
        
        // 简单边界限制
        const maxLeft = window.innerWidth - cameraContainer.offsetWidth;
        const maxTop = window.innerHeight - cameraContainer.offsetHeight;
        
        cameraContainer.style.left = `${Math.min(Math.max(0, newLeft), maxLeft)}px`;
        cameraContainer.style.top = `${Math.min(Math.max(0, newTop), maxTop)}px`;
        // 清除 bottom/right 属性，因为我们现在用 top/left 控制
        cameraContainer.style.bottom = 'auto';
        cameraContainer.style.right = 'auto';
    }, { passive: false });

    cameraContainer.addEventListener('touchend', () => {
        isDraggingContainer = false;
    });


    // ================= MediaPipe 识别与绘制 =================
    function onResults(results) {
        // 1. 绘制视频帧背景
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
        canvasCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);

        // 2. 如果检测到手，绘制赛博风格骨骼
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const currentGesture = detectGesture(landmarks);
            
            // 绘制连线 (黄色 - 科技感线条)
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                color: '#FFFF00', // 黄色
                lineWidth: 3
            });
            // 绘制关节 (红色 - 重点标记)
            drawLandmarks(canvasCtx, landmarks, {
                color: '#FF0000', // 红色
                lineWidth: 1,
                radius: 3
            });

            // 手势逻辑触发
            let statusText = `手势: ${currentGesture}\n`;
            if (!isExploded && lastGesture === 'FIST' && currentGesture === 'OPEN') {
                statusText += ">>> 激活: 烟花发射 <<<";
                for(let i=0; i<3; i++) setTimeout(() => createFirework(), i * 300);
            }
            window.logInfo(statusText);
            if (currentGesture !== 'BETWEEN') lastGesture = currentGesture;
        } else {
            lastGesture = 'UNKNOWN';
        }
        canvasCtx.restore();
    }

    function detectGesture(landmarks) { const wrist = landmarks[0]; const fingertips = [8, 12, 16, 20]; let foldedFingers = 0; fingertips.forEach(idx => { const tip = landmarks[idx]; const dist = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2)); if (dist < 0.15) foldedFingers++; }); if (foldedFingers >= 3) return 'FIST'; if (foldedFingers === 0) return 'OPEN'; return 'BETWEEN'; }

    async function initMediaPipe() {
        if (typeof Hands === 'undefined') {
            window.logError("MediaPipe 库加载失败，请检查网络");
            return;
        }

        window.logInfo("加载 AI 模型中...");
        
        const hands = new Hands({locateFile: (file) => {
            return `https://npm.elemecdn.com/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        try {
            const camera = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240, facingMode: 'user'
            });
            // 设置 Canvas 分辨率匹配视频流比例 (4:3)
            outputCanvas.width = 320;
            outputCanvas.height = 240;
            
            await camera.start();
            window.logInfo("系统就绪。\n拖动窗口，展示手势。");
        } catch (e) {
            window.logError("摄像头错误: " + e.message);
        }
    }

    // Interactions
    window.addEventListener('touchstart', (event) => { 
        if(isDraggingContainer) return; // 如果在拖拽摄像头，不触发3D交互
        touchStartTime = Date.now(); touchStartPos.set(event.touches[0].clientX, event.touches[0].clientY); if (event.touches.length > 1) { isMultiTouch = true; if (activeUUID) { const obj = floatingObjects.find(o => o.uuid === activeUUID); if (obj && (obj.userData.isTreeTop || obj.userData.pickType === 'photo')) { initialPinchDistance = getPinchDistance(event); initialScale = obj.userData.currentInspectionScale; } } } else { isMultiTouch = false; } isDragMove = false; }, { passive: false });
    window.addEventListener('touchmove', (event) => { if(isDraggingContainer) return; if (event.touches.length === 2) { isMultiTouch = true; if (activeUUID && initialPinchDistance > 0) { const obj = floatingObjects.find(o => o.uuid === activeUUID); if (obj && (obj.userData.isTreeTop || obj.userData.pickType === 'photo')) { const currentDistance = getPinchDistance(event); const scaleFactor = currentDistance / initialPinchDistance; const minScale = 0.5; const maxScale = obj.userData.isTreeTop ? 6.0 : 4.0; obj.userData.currentInspectionScale = clamp(initialScale * scaleFactor, minScale, maxScale); } } event.preventDefault(); return; } const dx = event.touches[0].clientX - touchStartPos.x; const dy = event.touches[0].clientY - touchStartPos.y; if (Math.sqrt(dx * dx + dy * dy) > 10) { isDragMove = true; } }, { passive: false });
    window.addEventListener('pointermove', (event) => { if (!isInspectionDragging || !activeUUID) return; const obj = floatingObjects.find(o => o.uuid === activeUUID); if (!obj || !obj.userData.isTreeTop) return; const deltaX = event.clientX - previousMouse.x; const deltaY = event.clientY - previousMouse.y; const rotateSpeed = isMobile ? 0.008 : 0.005; obj.rotation.y += deltaX * rotateSpeed; obj.rotation.x += deltaY * rotateSpeed; previousMouse.set(event.clientX, event.clientY); });
    window.addEventListener('pointerdown', (event) => { previousMouse.set(event.clientX, event.clientY); if (activeUUID) { const obj = floatingObjects.find(o => o.uuid === activeUUID); if (obj && obj.userData.isTreeTop) { mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const hits = raycaster.intersectObject(obj, true); if (hits.length > 0) isInspectionDragging = true; } } });
    window.addEventListener('pointerup', (event) => { isInspectionDragging = false; initialPinchDistance = 0; if (!isExploded) return; if (isMultiTouch) return; if (isDragMove) return; scene.updateMatrixWorld(true); mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(floatingObjects, true); const roots = []; const seen = new Set(); for (const hit of intersects) { const root = findInteractiveRoot(hit.object); if (root && !seen.has(root.uuid)) { seen.add(root.uuid); roots.push(root); } } if (roots.length === 0) { if (activeUUID) { const currentObj = floatingObjects.find(o => o.uuid === activeUUID); if (currentObj && currentObj.userData.isTreeTop) return; unpinCurrent(); } return; } let chosen = roots.find(r => r.userData.pickType === 'gift'); if (!chosen) chosen = roots[0]; if (activeUUID === chosen.uuid) return; pinObject(chosen); });
    window.addEventListener('wheel', (event) => { handleZoom(event.deltaY); }, { passive: false });
    function getPinchDistance(event) { const dx = event.touches[0].pageX - event.touches[1].pageX; const dy = event.touches[0].pageY - event.touches[1].pageY; return Math.sqrt(dx * dx + dy * dy); }
    function handleZoom(deltaY) { if (!activeUUID) return; const obj = floatingObjects.find(o => o.uuid === activeUUID); if (!obj || (!obj.userData.isTreeTop && obj.userData.pickType !== 'photo')) return; const scaleSensitivity = 0.001; obj.userData.currentInspectionScale += deltaY * -scaleSensitivity; const minScale = 0.5; const maxScale = obj.userData.isTreeTop ? 6.0 : 4.0; obj.userData.currentInspectionScale = clamp(obj.userData.currentInspectionScale, minScale, maxScale); }
    function unpinCurrent() { if (!activeUUID) return; const prev = floatingObjects.find(o => o.uuid === activeUUID); if (prev) { prev.userData.pinned = false; prev.userData.pinnedDist = null; if (prev.userData.isTreeTop || prev.userData.pickType === 'photo') prev.userData.currentInspectionScale = prev.userData.inspectionBaseScale; } activeUUID = null; isInspectionDragging = false; controls.enabled = true; controls.autoRotate = false; }
    function triggerExplosionOrReset() { if (activeUUID) { unpinCurrent(); return; } isExploded = !isExploded; isCameraMoving = true; controls.enabled = false; if (isExploded) targetCameraPos.copy(camera.userData.orbitPos); else targetCameraPos.copy(camera.userData.treePos); if (!isExploded) { const top = floatingObjects.find(o => o.userData && o.userData.isTreeTop); if (top) top.userData.treeFacingSet = false; } }
    function pinObject(root) { unpinCurrent(); activeUUID = root.uuid; root.userData.pinned = true; scene.updateMatrixWorld(true); const r = getWorldRadius(root); const baseDist = isMobile ? 70 : 60; const dist = clamp(Math.max(baseDist, computeSafeDistance(r)), 10, camera.far - 80); root.userData.pinnedDist = dist; if (root.userData.isTreeTop) { const focusPos = getFocusPosByDistance(dist); root.userData.inspectionPos.copy(focusPos); root.userData.currentInspectionScale = root.userData.inspectionBaseScale; controls.enabled = false; } else { if (root.userData.pickType === 'gift' || root.type === 'Group') faceCameraUprightY(root); else if (root.userData.pickType === 'photo') { root.lookAt(camera.position); root.userData.currentInspectionScale = root.userData.inspectionBaseScale; } else root.lookAt(camera.position); root.userData.pinnedRot.copy(root.rotation); controls.enabled = false; } }
    window.addEventListener('dblclick', () => { triggerExplosionOrReset(); });
    window.addEventListener('touchend', (event) => { if(isDraggingContainer) return; if (event.touches.length === 0) setTimeout(() => { isMultiTouch = false; }, 100); const currentTime = new Date().getTime(); const tapLength = currentTime - lastTapTime; if (tapLength < 300 && tapLength > 0) { if (event.changedTouches.length === 1 && !isDragMove) { triggerExplosionOrReset(); event.preventDefault(); } } lastTapTime = currentTime; });

    function updateCameraPosition() { const aspect = window.innerWidth / window.innerHeight; if (aspect < 1) { camera.userData.treePos = new THREE.Vector3(0, 5, 110); camera.userData.orbitPos = new THREE.Vector3(0, 30, 280); } else { camera.userData.treePos = new THREE.Vector3(0, 5, 80); camera.userData.orbitPos = new THREE.Vector3(0, 40, 280); } if (!camera.userData.isInitialized) { camera.position.copy(camera.userData.treePos); camera.userData.isInitialized = true; } }

    function animate() {
      requestAnimationFrame(animate);
      updateFireworks();
      const time = Date.now();
      lightBulbs.forEach(bulb => { const t = time * 0.005; const sparkle = Math.sin(t * 10 + bulb.userData.blinkOffset) * 0.5 + Math.sin(t * 25 + bulb.userData.blinkOffset * 2) * 0.3; bulb.material.emissiveIntensity = 2.5 + sparkle * 1.5; });
      if (isCameraMoving) { camera.position.lerp(targetCameraPos, 0.03); camera.lookAt(0, 5, 0); if (camera.position.distanceTo(targetCameraPos) < 1.0) { isCameraMoving = false; controls.enabled = true; controls.update(); } } else { controls.update(); }
      if (!isExploded) { starMesh.rotation.y += 0.0003; starMesh.rotation.x += 0.0001; }
      const lerpSpeed = 0.02;
      floatingObjects.forEach(obj => { if (obj.userData.pinned && obj.uuid === activeUUID) { if (obj.userData.isTreeTop) { alignLocalCenterToWorldPoint(obj, obj.userData.localCenter, obj.userData.inspectionPos); let bigScale = obj.userData.originScale.clone().multiplyScalar(obj.userData.currentInspectionScale); obj.scale.lerp(bigScale, 0.12); return; } const dist = obj.userData.pinnedDist || (isMobile ? 70 : 60); const focusPos = getFocusPosByDistance(dist); if (obj.userData.pickType === 'photo') obj.lookAt(camera.position); else obj.rotation.copy(obj.userData.pinnedRot); alignLocalCenterToWorldPoint(obj, obj.userData.localCenter, focusPos); let bigScale; if (obj.type === 'Group') bigScale = obj.userData.originScale.clone().multiplyScalar(1.5); else if (obj.geometry && obj.geometry.type === 'PlaneGeometry') bigScale = obj.userData.explodedScale.clone().multiplyScalar(obj.userData.currentInspectionScale); else bigScale = obj.userData.originScale.clone().multiplyScalar(2.0); obj.scale.lerp(bigScale, 0.12); return; } if (!isExploded && obj.userData.isTreeTop) { const topPoint = getTreeTopWorldPoint(tmpV3c); topPoint.y -= 1.5; snapBottomCenterToWorldPoint(obj, topPoint); if (!obj.userData.treeFacingSet) { obj.rotation.x = 0; obj.rotation.z = 0; obj.rotation.y = (obj.userData.yawOffset || 0); obj.userData.treeFacingSet = true; } obj.scale.lerp(obj.userData.originScale, 0.08); return; } let targetScale; if (isExploded) targetScale = obj.userData.isExplodedVisible ? obj.userData.explodedScale : new THREE.Vector3(0.001, 0.001, 0.001); else targetScale = obj.userData.originScale; obj.scale.lerp(targetScale, lerpSpeed); if (isExploded) { obj.userData.orbitAngle -= obj.userData.orbitSpeed; const targetX = Math.cos(obj.userData.orbitAngle) * obj.userData.orbitRadius; const targetZ = Math.sin(obj.userData.orbitAngle) * obj.userData.orbitRadius; const orbitalPos = new THREE.Vector3(targetX, obj.userData.orbitY, targetZ); obj.position.lerp(orbitalPos, lerpSpeed); obj.rotation.x += obj.userData.floatSpeed.x; obj.rotation.y += obj.userData.floatSpeed.y; } else { obj.position.lerp(obj.userData.originPos, lerpSpeed); obj.quaternion.slerp(new THREE.Quaternion().setFromEuler(obj.userData.originRot), lerpSpeed); } });
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); updateCameraPosition(); });
    updateCameraPosition();
    animate();

    if (isMobile) {
        window.logInfo("检测到手机\n正在初始化...");
        setTimeout(() => { initMediaPipe(); }, 3000);
    } else {
        window.logInfo("电脑端模式\n请用手机访问以测试摄像头");
    }
  </script>
</body>
</html>
