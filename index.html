<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>我的3D照片圣诞树 - 赛博完全体</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none; /* 禁止浏览器默认缩放和滚动 */
      font-family: 'Arial', sans-serif;
    }

    /* === 1. 新增：启动遮罩层 === */
    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.92); z-index: 2000;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: #fff; text-align: center; transition: opacity 0.8s;
    }
    #start_btn {
      padding: 15px 40px; font-size: 18px; color: #444; background: #222; 
      border: 1px solid #444; border-radius: 50px; font-weight: bold; 
      pointer-events: none; transition: all 0.4s ease; text-transform: uppercase; margin-top: 20px;
    }
    #start_btn.ready {
      color: #000; background: #00ffff; border-color: #00ffff;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); cursor: pointer; pointer-events: auto;
    }

    /* === 2. 新增：悬浮摄像头窗口 (可拖拽) === */
    #cam_window {
      position: absolute; bottom: 20px; right: 20px; width: 130px; height: 173px; /* 4:3 比例 */
      z-index: 1000; background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(0, 255, 255, 0.5); border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
      overflow: hidden; display: none; /* 启动前隐藏 */
      backdrop-filter: blur(4px);
    }
    /* 画布镜像翻转 */
    #hand_canvas { width: 100%; height: 100%; transform: scaleX(-1); display: block; }
    /* 隐藏原始视频 */
    #raw_video { display: none; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
  
  <script>
    function activateBtn() {
      const btn = document.getElementById('start_btn');
      if(btn) { btn.classList.add('ready'); btn.innerText = '启动系统 / START'; }
    }
    // 稍微延迟一下确保库加载
    window.addEventListener('load', () => setTimeout(activateBtn, 1000));
  </script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="overlay">
    <div style="font-size: 2rem; color: #00ffff; text-shadow: 0 0 20px #00ffff;">CYBER CHRISTMAS</div>
    <div style="color: #888; margin-top: 10px;">Gesture Control System Loading...</div>
    <button id="start_btn">LOADING...</button>
  </div>

  <div id="cam_window"><canvas id="hand_canvas"></canvas></div>
  <video id="raw_video" playsinline webkit-playsinline></video>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { STLLoader } from 'three/addons/loaders/STLLoader.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

    // ================= 1. 核心布局数据 (保持不变) =================
    const FIXED_LAYOUT = [
      { "name": "giftbox4.glb", "pos": [10.33, -32, 59.09], "rot": 1.66 }, { "name": "giftbox1.glb", "pos": [21.06, -32, -2.97], "rot": 1.06 }, { "name": "giftbox3.glb", "pos": [10.07, -32, 39.08], "rot": 2.33 }, { "name": "giftbox3.glb", "pos": [6.9, -32, 63.75], "rot": 1.26 }, { "name": "giftbox2.glb", "pos": [23.1, -32, 48.07], "rot": 1.23 }, { "name": "giftbox1.glb", "pos": [18.68, -32, 0.85], "rot": 3.13 }, { "name": "giftbox4.glb", "pos": [1, -32, 13.04], "rot": 1.58 }, { "name": "giftbox1.glb", "pos": [-10.65, -32, -14.06], "rot": 0.05 }, { "name": "giftbox4.glb", "pos": [30.9, -32, 12.76], "rot": 1.51 }, { "name": "giftbox5.glb", "pos": [-16.37, -32, 66.98], "rot": 0.73 }, { "name": "giftbox2.glb", "pos": [-44.31, -32, 52.75], "rot": 0.14 }, { "name": "giftbox1.glb", "pos": [4.98, -32, 6.17], "rot": 1.06 }, { "name": "giftbox4.glb", "pos": [3.07, -32, 39.17], "rot": 0.33 }, { "name": "giftbox5.glb", "pos": [22.66, -32, 50.69], "rot": 2.3 }, { "name": "giftbox2.glb", "pos": [19.69, -32, -18.06], "rot": 2.8 }, { "name": "giftbox3.glb", "pos": [39.87, -32, 22.91], "rot": 1.87 }, { "name": "giftbox4.glb", "pos": [-25.88, -32, 43.69], "rot": 1.18 }, { "name": "giftbox2.glb", "pos": [33.85, -32, -3.28], "rot": 2.15 }, { "name": "giftbox2.glb", "pos": [18.23, -32, 22.29], "rot": 1.63 }
    ];

    // ================= 2. 基础场景 (保持不变) =================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.environment = scene.background;
    scene.fog = new THREE.FogExp2(0x000000, 0.0015);

    const treeRoot = new THREE.Group();
    scene.add(treeRoot);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2.0);
    hemiLight.position.set(0, 50, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);

    const cameraLight = new THREE.PointLight(0xffffff, 1.5);
    cameraLight.position.set(5, 5, 5);
    camera.add(cameraLight);
    scene.add(camera);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.useLegacyLights = false;

    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = false;
    controls.minDistance = 1;
    controls.maxDistance = 1000;
    controls.target.set(0, 5, 0);

    // ================= 3. 全局变量 (保持不变，增加 AI 变量) =================
    const floatingObjects = [];
    const lightBulbs = []; 
    let isExploded = false;
    const isMobile = window.innerWidth < 768;

    let isCameraMoving = false;
    let targetCameraPos = new THREE.Vector3();

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    let activeUUID = null;

    // 交互控制变量
    let isInspectionDragging = false;
    const previousMouse = new THREE.Vector2();
    let initialPinchDistance = 0;
    let initialScale = 0;
    let lastTapTime = 0;

    // 防误触核心变量
    let touchStartTime = 0;
    let isMultiTouch = false;
    let isDragMove = false;
    const touchStartPos = new THREE.Vector2();

    // 【新增】烟花粒子系统变量
    const fireworks = []; 
    // 【新增】手势变量
    let handLandmarker = null;
    let lastGesture = 'UNKNOWN';
    const HAND_CONNECTIONS = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];

    const tmpV3a = new THREE.Vector3();
    const tmpV3b = new THREE.Vector3();
    const tmpV3c = new THREE.Vector3();
    const tmpBox = new THREE.Box3();

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function findInteractiveRoot(obj) {
      let cur = obj;
      while (cur && cur !== scene) {
        if (cur.userData && cur.userData.isInteractive) return cur;
        cur = cur.parent;
      }
      return null;
    }

    function faceCameraUprightY(obj) {
      obj.getWorldPosition(tmpV3a);
      camera.getWorldPosition(tmpV3b);
      const dx = tmpV3b.x - tmpV3a.x;
      const dz = tmpV3b.z - tmpV3a.z;
      const yaw = Math.atan2(dx, dz);
      obj.rotation.x = 0;
      obj.rotation.z = 0;
      obj.rotation.y = yaw;
    }

    function getFocusPosByDistance(dist) {
      const focusPos = new THREE.Vector3();
      camera.getWorldDirection(focusPos).multiplyScalar(dist).add(camera.position);
      return focusPos;
    }

    function computeSafeDistance(radiusWorld) {
      const vFov = THREE.MathUtils.degToRad(camera.fov);
      const hFov = 2 * Math.atan(Math.tan(vFov / 2) * camera.aspect);
      const minHalfFov = Math.min(vFov, hFov) / 2;
      const margin = 2.0;
      const dist = (radiusWorld * margin) / Math.tan(minHalfFov);
      return dist + radiusWorld * 0.8;
    }

    function alignLocalCenterToWorldPoint(obj, localCenter, worldTarget) {
      const worldCenterNow = obj.localToWorld(localCenter.clone());
      const delta = worldTarget.clone().sub(worldCenterNow);
      obj.position.add(delta);
    }

    function getWorldRadius(obj) {
      tmpBox.setFromObject(obj);
      const size = tmpBox.getSize(tmpV3c);
      let r = 0.5 * Math.sqrt(size.x * size.x + size.y * size.y + size.z * size.z);
      r = clamp(r, 2.0, 40.0);
      return r;
    }

    // ================= 树顶逻辑 (保持不变) =================
    function getTreeTopWorldPoint(out = new THREE.Vector3()) {
      const box = new THREE.Box3();
      let has = false;
      for (const obj of floatingObjects) {
        if (!obj.userData) continue;
        if (obj.userData.pickType === 'gift') continue;
        if (obj.userData.isTreeTop) continue;
        box.expandByObject(obj);
        has = true;
      }
      if (!has) {
        out.set(controls.target.x, 30, controls.target.z);
        return out;
      }
      const topY = box.max.y;
      const centerX = (box.min.x + box.max.x) / 2;
      const centerZ = (box.min.z + box.max.z) / 2;
      out.set(centerX, topY, centerZ);
      return out;
    }

    function snapBottomCenterToWorldPoint(obj, worldPoint) {
      const local = obj.userData.bottomCenterLocal;
      if (!local) return;
      const worldNow = obj.localToWorld(local.clone());
      const delta = worldPoint.clone().sub(worldNow);
      obj.positio