<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>圣诞树 - 强力调试版</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; font-family: sans-serif; }
    
    /* 启动层 */
    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.9); z-index: 2000;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: #0ff; text-align: center;
    }
    
    /* 按钮状态样式 */
    #start_btn {
      padding: 20px 50px; font-size: 22px; color: #000; background: #333; /* 默认灰色 */
      border: 2px solid #555; border-radius: 8px; margin-top: 30px; 
      font-weight: bold; pointer-events: none; /* 默认不可点 */
      transition: 0.3s;
    }
    /* 激活状态 */
    #start_btn.ready {
      background: #00ffff; border-color: #00ffff; 
      box-shadow: 0 0 20px #00ffff; cursor: pointer; pointer-events: auto;
    }

    #status_log { 
      margin-top: 20px; color: #0f0; font-size: 14px; 
      white-space: pre-wrap; max-width: 80%; text-align: left; 
      border: 1px solid #333; padding: 10px; background: #111;
    }

    /* 悬浮摄像头窗口 */
    #cam_window {
      position: absolute; bottom: 20px; right: 20px; width: 120px; height: 160px;
      z-index: 1000; background: #000;
      border: 2px solid #0ff; border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
      overflow: hidden; display: none; 
    }
    #hand_canvas { width: 100%; height: 100%; transform: scaleX(-1); display: block; }
    #raw_video { display: none; }
  </style>

  <script>
    window.onerror = function(msg, url, line) {
      const txt = "错误: " + msg + "\n行号: " + line;
      alert(txt); // 直接弹窗报错
      const log = document.getElementById('status_log');
      if(log) log.innerText += "\n[ERROR] " + msg;
    };
    
    function log(msg) {
        const el = document.getElementById('status_log');
        if(el) el.innerText += '\n> ' + msg;
        console.log(msg);
    }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous" 
    onload="window.libLoaded=true; document.getElementById('start_btn').classList.add('ready'); document.getElementById('start_btn').innerText='系统就绪 (点击启动)';"
    onerror="alert('MediaPipe 库加载失败！请检查网络或切换 Wi-Fi');"></script>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
  </script>
</head>

<body>
  <div id="overlay">
    <div style="font-size: 24px; text-shadow: 0 0 10px #0ff;">赛博系统初始化</div>
    <div id="status_log">正在下载 AI 核心文件 (Hands.js)...</div>
    <button id="start_btn">下载中...</button>
  </div>

  <div id="cam_window"><canvas id="hand_canvas"></canvas></div>
  <video id="raw_video" playsinline webkit-playsinline></video>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

    // ================= 变量定义 =================
    const startBtn = document.getElementById('start_btn');
    const overlay = document.getElementById('overlay');
    const video = document.getElementById('raw_video');
    const canvas = document.getElementById('hand_canvas');
    const ctx = canvas.getContext('2d');
    
    let handLandmarker = null;
    let isExploded = false;
    let lastGesture = 'UNKNOWN';
    
    // 手部连接定义
    const HAND_CONNECTIONS = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];

    // ================= 1. 启动逻辑 =================
    startBtn.onclick = async () => {
        log("按钮被点击");
        
        // 检查 Hands 是否存在
        if (typeof window.Hands === 'undefined') {
            alert("Hands 对象未找到，库可能未完全加载");
            return;
        }

        try {
            startBtn.innerText = "启动中...";
            
            // 初始化 AI
            log("配置 AI 模型...");
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onAIResults);
            handLandmarker = hands;

            // 启动摄像头
            log("请求摄像头权限...");
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: false,
                video: { facingMode: "user", width: 320, height: 240 }
            });
            
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                video.play();
                log("摄像头已运行");
                overlay.style.display = 'none';
                document.getElementById('cam_window').style.display = 'block';
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                processVideoFrame();
            };

        } catch (e) {
            alert("启动错误: " + e.message);
            log("ERROR: " + e.message);
            startBtn.innerText = "重试";
        }
    };

    async function processVideoFrame() {
        if (handLandmarker && video.readyState >= 2) {
            await handLandmarker.send({image: video});
        }
        requestAnimationFrame(processVideoFrame);
    }

    // ================= 2. 绘制与识别 =================
    function onAIResults(results) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 绘制骨骼 (赛博黄)
            ctx.lineWidth = 2; ctx.strokeStyle = '#FFFF00';
            for (const [s, e] of HAND_CONNECTIONS) {
                const p1 = landmarks[s]; const p2 = landmarks[e];
                ctx.beginPath(); 
                ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
                ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height);
                ctx.stroke();
            }
            
            // 绘制关节 (赛博红)
            ctx.fillStyle = '#FF0000';
            for (const lm of landmarks) {
                ctx.beginPath(); ctx.arc(lm.x * canvas.width, lm.y * canvas.height, 3, 0, 2 * Math.PI); ctx.fill();
            }

            // 手势判断
            const gesture = detectGesture(landmarks);
            if (!isExploded && lastGesture === 'FIST' && gesture === 'OPEN') {
                for(let i=0; i<5; i++) setTimeout(createFirework, i*200);
            }
            if (gesture !== 'BETWEEN') lastGesture = gesture;
        }
    }

    function detectGesture(lm) {
        const tips = [8,12,16,20]; let folded = 0;
        const wrist = lm[0];
        tips.forEach(i => {
            if (Math.sqrt(Math.pow(lm[i].x - wrist.x, 2) + Math.pow(lm[i].y - wrist.y, 2)) < 0.15) folded++;
        });
        if(folded >= 3) return 'FIST';
        if(folded === 0) return 'OPEN';
        return 'BETWEEN';
    }

    // ================= 3. 悬浮窗拖拽 =================
    const camWin = document.getElementById('cam_window');
    let dragData = { active: false, x: 0, y: 0, initialX: 0, initialY: 0 };

    camWin.addEventListener('touchstart', (e) => {
        dragData.active = true;
        dragData.initialX = e.touches[0].clientX - camWin.offsetLeft;
        dragData.initialY = e.touches[0].clientY - camWin.offsetTop;
        e.stopPropagation();
    }, {passive: false});

    window.addEventListener('touchmove', (e) => {
        if (!dragData.active) return;
        e.preventDefault();
        camWin.style.left = (e.touches[0].clientX - dragData.initialX) + "px";
        camWin.style.top = (e.touches[0].clientY - dragData.initialY) + "px";
        camWin.style.right = 'auto'; camWin.style.bottom = 'auto';
    }, {passive: false});

    window.addEventListener('touchend', () => dragData.active = false);

    // ================= 4. Three.js 核心 (简版) =================
    // 这里的逻辑保持不变，用于渲染圣诞树
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(0, 5, 100);
    const renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement);
    
    // 灯光
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 2));
    const dl = new THREE.DirectionalLight(0xffffff, 1.5); dl.position.set(10,20,10); scene.add(dl);

    // 星空
    const starGeo = new THREE.BufferGeometry(); const starPos = []; 
    for(let i=0; i<1000; i++) starPos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    const starMesh = new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size:2})); scene.add(starMesh);

    // 树 (简单球体代替，保证先跑通)
    const treeGroup = new THREE.Group(); scene.add(treeGroup);
    
    // 加载你的 GLB
    const gltfLoader = new GLTFLoader();
    gltfLoader.load('clawhauser.glb', (gltf) => {
        const m = gltf.scene; m.scale.set(10,10,10); m.position.y = 30; treeGroup.add(m);
        // 这里只是为了让它能被点击和交互，简化了逻辑
        m.userData = { isTreeTop: true };
    }, undefined, (e)=>{ console.log('模型加载中') });

    // 烟花
    const fireworks = [];
    function createFirework() {
        const geo = new THREE.BufferGeometry(); const pos = []; const vel = [];
        const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
        for(let i=0; i<100; i++) {
            pos.push(0, 40, 0);
            vel.push((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({size:3, color:color, transparent:true});
        const points = new THREE.Points(geo, mat); points.userData = {vel: vel, life: 1};
        scene.add(points); fireworks.push(points);
    }

    function animate() {
        requestAnimationFrame(animate);
        starMesh.rotation.y += 0.001;
        
        // 烟花更新
        for(let i=fireworks.length-1; i>=0; i--) {
            const fw = fireworks[i]; const pos = fw.geometry.attributes.position.array;
            fw.userData.life -= 0.02; fw.material.opacity = fw.userData.life;
            for(let j=0; j<fw.userData.vel.length; j+=3) {
                pos[j] += fw.userData.vel[j]; pos[j+1] += fw.userData.vel[j+1] - 0.05; pos[j+2] += fw.userData.vel[j+2];
            }
            fw.geometry.attributes.position.needsUpdate = true;
            if(fw.userData.life <= 0) { scene.remove(fw); fireworks.splice(i,1); }
        }
        
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
    
    // 3D交互简版
    window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  </script>
</body>
</html>
