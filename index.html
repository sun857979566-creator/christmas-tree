<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>我的3D照片圣诞树 - 最终完美版</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      font-family: 'Arial', sans-serif;
    }

    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.92); z-index: 2000;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: #fff; text-align: center; transition: opacity 0.8s;
    }
    #start_btn {
      padding: 15px 40px; font-size: 18px; color: #444; background: #222; 
      border: 1px solid #444; border-radius: 50px; font-weight: bold; 
      pointer-events: none; transition: all 0.4s ease; text-transform: uppercase; margin-top: 20px;
    }
    #start_btn.ready {
      color: #000; background: #00ffff; border-color: #00ffff;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); cursor: pointer; pointer-events: auto;
    }

    #cam_window {
      position: absolute; bottom: 20px; right: 20px; width: 130px; height: 173px;
      z-index: 1000; background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(0, 255, 255, 0.5); border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
      overflow: hidden; display: none;
      backdrop-filter: blur(4px);
      transition: all 0.3s ease;
    }
    #hand_canvas { width: 100%; height: 100%; transform: scaleX(-1); display: block; }
    #raw_video { display: none; }

    /* 控制按钮 */
    .control-btn {
        position: absolute; top: 20px; width: 44px; height: 44px;
        background: rgba(255, 255, 255, 0.15); border-radius: 50%;
        display: flex; justify-content: center; align-items: center;
        cursor: pointer; z-index: 1500; transition: all 0.3s ease;
        backdrop-filter: blur(2px); border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .control-btn:hover { background: rgba(255, 255, 255, 0.3); }
    .control-btn svg { width: 24px; height: 24px; fill: rgba(255, 255, 255, 0.9); transition: fill 0.3s ease; }
    .control-btn.off svg { fill: rgba(255, 255, 255, 0.3); }
    #cam_toggle { left: 20px; }
    #music_toggle { right: 20px; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
  
  <script>
    // 强制激活按钮，解决一直LOADING的问题
    function activateBtn() {
      const btn = document.getElementById('start_btn');
      if(btn) { 
        btn.classList.add('ready'); 
        btn.innerText = '欢迎来到MIA的圣诞树'; 
      }
    }
    setTimeout(activateBtn, 2000); // 2秒后强制激活
  </script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://npm.elemecdn.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://npm.elemecdn.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="cam_toggle" class="control-btn" style="display:none;">
      <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3.2"/><path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>
  </div>
  <div id="music_toggle" class="control-btn" style="display:none;">
      <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/><path d="M0 0h24v24H0z" fill="none"/></svg>
  </div>

  <div id="overlay">
    <div style="font-size: 2rem; color: #00ffff; text-shadow: 0 0 20px #00ffff;">CYBER CHRISTMAS</div>
    <div style="color: #888; margin-top: 10px;">Gesture Control System Loading...</div>
    <button id="start_btn">LOADING...</button>
  </div>

  <div id="cam_window"><canvas id="hand_canvas"></canvas></div>
  <video id="raw_video" playsinline webkit-playsinline></video>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

    // ================= 基础场景 =================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.0015);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.useLegacyLights = false;
    document.body.appendChild(renderer.domElement);
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor=0.05; controls.minDistance=1; controls.maxDistance=1000; controls.target.set(0, 20, 0);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2.0); hemiLight.position.set(0, 50, 0); scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); dirLight.position.set(10, 20, 10); scene.add(dirLight);

    // ================= 圣诞树逻辑 (保持原样) =================
    const treeRoot = new THREE.Group(); scene.add(treeRoot);
    const floatingObjects = [];
    
    // 星空
    function createStarTexture() {
        const c=document.createElement('canvas');c.width=32;c.height=32;
        const x=c.getContext('2d');
        const g=x.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0,'rgba(255,255,255,1)');g.addColorStop(1,'rgba(0,0,0,0)');
        x.fillStyle=g;x.fillRect(0,0,32,32);return new THREE.CanvasTexture(c);
    }
    const starGeo=new THREE.BufferGeometry();
    const starPos=new Float32Array(4500);
    for(let i=0;i<4500;i++) starPos[i]=(Math.random()-0.5)*1500;
    starGeo.setAttribute('position',new THREE.BufferAttribute(starPos,3));
    const starMat=new THREE.PointsMaterial({size:2.5,map:createStarTexture(),transparent:true,opacity:0.8,blending:THREE.AdditiveBlending,depthWrite:false});
    scene.add(new THREE.Points(starGeo,starMat));

    const gltfLoader = new GLTFLoader();
    // 你的模型
    gltfLoader.load('clawhauser.glb', (g) => {
        const m=g.scene; m.scale.set(10,10,10); m.rotation.set(-0.35,0,1.57);
        const r=new THREE.Group(); r.add(m); r.position.set(0,30,0);
        r.userData={originPos:r.position.clone()}; treeRoot.add(r); floatingObjects.push(r);
    }, undefined, ()=>{});

    const boxPositions = [[10,-32,59], [-10,-32,-14], [20,-32,0], [0,-32,20]];
    ['giftbox1.glb','giftbox2.glb'].forEach((n,i)=>{
        gltfLoader.load(n,(g)=>{
            const m=g.scene.clone(); m.scale.set(15,15,15);
            const gr=new THREE.Group(); gr.add(m); if(boxPositions[i]) gr.position.set(...boxPositions[i]);
            gr.userData={originPos:gr.position.clone()}; treeRoot.add(gr); floatingObjects.push(gr);
        });
    });

    // ================= 【完美烟花逻辑】(仿照视频效果) =================
    // 1. 文字纹理生成
    function createTextTexture(text) {
        const c=document.createElement('canvas'); c.width=1024; c.height=256;
        const x=c.getContext('2d');
        x.font='bold 80px "Arial", sans-serif'; x.textAlign='center'; x.textBaseline='middle';
        x.shadowColor='rgba(255, 223, 0, 1)'; x.shadowBlur=30; 
        x.fillStyle='#fffacd'; // 柠檬绸色
        x.fillText(text, 512, 128); return new THREE.CanvasTexture(c);
    }
    const textTexture = createTextTexture("MERRY CHRISTMAS");

    // 2. 烟花类 (Class)
    class Firework {
        constructor(scene) {
            this.scene = scene; this.state = 'dead';
            this.launchPos = new THREE.Vector3(0,-30,0);
            // 目标高度 60-100
            this.targetPos = new THREE.Vector3((Math.random()-0.5)*30, 70+Math.random()*30, (Math.random()-0.5)*30);
            this.vel = new THREE.Vector3().subVectors(this.targetPos,this.launchPos).normalize().multiplyScalar(2.2);
            this.pCount=1200; // 粒子数
            this.pos=new Float32Array(this.pCount*3); 
            this.col=new Float32Array(this.pCount*3); 
            this.v=[]; 
        }

        launch() {
            this.state='rising'; this.curPos=this.launchPos.clone();
            const g=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]);
            // 发射时的金色光点
            this.rocket=new THREE.Points(g,new THREE.PointsMaterial({color:0xffd700,size:4,blending:THREE.AdditiveBlending}));
            this.rocket.position.copy(this.curPos); this.scene.add(this.rocket);
        }

        explode() {
            this.state='exploding'; this.scene.remove(this.rocket);
            
            // 颜色：金色系 (Gold)
            const c=new THREE.Color(0xffd700); 

            for(let i=0;i<this.pCount;i++){
                this.pos[i*3]=this.targetPos.x; this.pos[i*3+1]=this.targetPos.y; this.pos[i*3+2]=this.targetPos.z;
                // 微微的颜色抖动
                this.col[i*3]=c.r + (Math.random()-0.5)*0.2; 
                this.col[i*3+1]=c.g + (Math.random()-0.5)*0.2; 
                this.col[i*3+2]=c.b;

                // 爆炸物理：球形扩散
                const theta=Math.random()*6.28; const phi=Math.acos(Math.random()*2-1); 
                const s=0.8+Math.random()*2.5; // 初始爆炸力度
                this.v.push({
                    x:s*Math.sin(phi)*Math.cos(theta),
                    y:s*Math.sin(phi)*Math.sin(theta),
                    z:s*Math.cos(phi)
                });
            }
            this.geo=new THREE.BufferGeometry();
            this.geo.setAttribute('position',new THREE.BufferAttribute(this.pos,3));
            this.geo.setAttribute('color',new THREE.BufferAttribute(this.col,3));
            // 复用星星贴图
            this.mat=new THREE.PointsMaterial({size:1.8,vertexColors:true,blending:THREE.AdditiveBlending,transparent:true,opacity:1,depthWrite:false,map:starMat.map});
            this.pts=new THREE.Points(this.geo,this.mat); this.scene.add(this.pts);
            
            // 文字Sprite
            this.txt=new THREE.Sprite(new THREE.SpriteMaterial({map:textTexture,transparent:true,opacity:0}));
            this.txt.position.copy(this.targetPos); 
            this.txt.scale.set(70,18,1); // 文字大小
            this.scene.add(this.txt);
            this.life=1.0;
        }

        update() {
            if(this.state==='rising') {
                this.curPos.add(this.vel); this.rocket.position.copy(this.curPos); 
                this.vel.y-=0.03; // 重力
                if(this.vel.y<=0.1) this.explode();
            } else if(this.state==='exploding') {
                const p=this.geo.attributes.position.array;
                for(let i=0;i<this.pCount;i++){
                    const v=this.v[i]; 
                    
                    // 【视频效果核心】：空气阻力 + 重力 = 柳枝下垂感
                    v.x*=0.93; v.y*=0.93; v.z*=0.93; // 强阻力，让粒子水平方向快速停下
                    v.y-=0.04; // 强重力，让粒子垂直下落
                    
                    p[i*3]+=v.x; p[i*3+1]+=v.y; p[i*3+2]+=v.z;
                }
                this.geo.attributes.position.needsUpdate=true; 
                
                this.life-=0.006; // 延长存在时间
                this.mat.opacity=this.life; 
                
                // 闪烁效果
                this.mat.size = (Math.random()>0.5) ? 1.8 : 1.0; 

                // 文字浮现逻辑
                if(this.life<0.9 && this.life>0.4) { 
                    this.txt.material.opacity = Math.min(1, this.txt.material.opacity+0.03);
                    this.txt.position.y += 0.03; // 文字缓慢上升
                } else if(this.life<=0.4) {
                    this.txt.material.opacity -= 0.02;
                }

                if(this.life<=0) { this.scene.remove(this.pts); this.scene.remove(this.txt); this.state='dead'; }
            }
        }
    }
    const activeFw=[];
    function triggerFw() { const f=new Firework(scene); f.launch(); activeFw.push(f); }

    // ================= 核心控制 =================
    const startBtn = document.getElementById('start_btn');
    const overlay = document.getElementById('overlay');
    const video = document.getElementById('raw_video');
    const canvas = document.getElementById('hand_canvas');
    const ctx = canvas.getContext('2d');
    const camWin = document.getElementById('cam_window');

    const musicUrl = 'https://raw.githubusercontent.com/sun857979566-creator/christmas-tree/main/just%20love%20u.mp3';
    let sound=null;

    function initMusic() {
        const l=new THREE.AudioListener(); camera.add(l);
        sound=new THREE.Audio(l); const ld=new THREE.AudioLoader();
        document.getElementById('music_toggle').classList.add('off');
        ld.load(musicUrl, (b)=>{
            sound.setBuffer(b); sound.setLoop(true); sound.setVolume(0.5);
            sound.play(); document.getElementById('music_toggle').classList.remove('off');
        });
    }

    startBtn.onclick = async () => {
        try {
            // 强制激活音频
            const ac=THREE.AudioContext.getContext(); if(ac.state==='suspended') ac.resume();
            
            startBtn.innerText = '正在启动...';
            initMusic();

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`});
            hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            hands.onResults(onAIResults);
            
            const stream = await navigator.mediaDevices.getUserMedia({video: {facingMode: "user", width:320, height:240}});
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                video.play();
                overlay.style.opacity = '0';
                setTimeout(() => { overlay.style.display = 'none'; }, 800);
                camWin.style.display = 'block';
                document.getElementById('cam_toggle').style.display = 'flex';
                document.getElementById('music_toggle').style.display = 'flex';
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                processVideo();
            };
        } catch(e) { 
            alert("启动出错: " + e.message); 
            startBtn.innerText = '重试';
        }
    };

    // 手势识别与渲染
    let handLandmarker;
    async function processVideo() {
        if(video.readyState >= 2) await handLandmarker.send({image: video});
        requestAnimationFrame(processVideo);
    }
    
    let lastG='UNKNOWN';
    function onAIResults(res) {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(res.image,0,0,canvas.width,canvas.height);
        if(res.multiHandLandmarks && res.multiHandLandmarks.length>0) {
            const lm=res.multiHandLandmarks[0];
            // 画手
            ctx.fillStyle='#ff0000'; ctx.strokeStyle='#ffff00'; ctx.lineWidth=2;
            const conn=[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
            conn.forEach(([i,j])=>{ctx.beginPath();ctx.moveTo(lm[i].x*320,lm[i].y*240);ctx.lineTo(lm[j].x*320,lm[j].y*240);ctx.stroke();});
            lm.forEach(p=>{ctx.beginPath();ctx.arc(p.x*320,p.y*240,3,0,6.28);ctx.fill();});

            // 握拳检测
            let folded=0; [8,12,16,20].forEach(i=>{
                if(Math.sqrt(Math.pow(lm[i].x-lm[0].x,2)+Math.pow(lm[i].y-lm[0].y,2))<0.15) folded++;
            });
            const g = folded>=3?'FIST':(folded===0?'OPEN':'BETWEEN');
            
            // 【触发烟花】
            if(lastG==='FIST' && g==='OPEN') {
                triggerFw(); // 触发一颗
                setTimeout(triggerFw, 400); // 连发
                setTimeout(triggerFw, 800); 
            }
            if(g!=='BETWEEN') lastG=g;
        }
    }

    // 动画循环
    function animate() {
        requestAnimationFrame(animate); controls.update();
        
        // 更新烟花
        for(let i=activeFw.length-1;i>=0;i--) { activeFw[i].update(); if(activeFw[i].state==='dead') activeFw.splice(i,1); }
        
        const t=Date.now()*0.001; 
        // 浮动动画
        floatingObjects.forEach(o=>{ o.position.y += Math.sin(t+o.userData.originPos.x)*0.02; });
        renderer.render(scene, camera);
    }

    // 事件监听
    window.addEventListener('resize', () => {
        camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
    });
    
    document.getElementById('cam_toggle').onclick = function() {
        if(camWin.style.display==='none') { camWin.style.display='block'; this.classList.remove('off'); }
        else { camWin.style.display='none'; this.classList.add('off'); }
    };
    document.getElementById('music_toggle').onclick = function() {
        if(sound && sound.isPlaying) { sound.pause(); this.classList.add('off'); }
        else if(sound) { sound.play(); this.classList.remove('off'); }
    };
    
    // 拖拽
    let isD=false,sX,sY;
    camWin.addEventListener('touchstart',e=>{isD=true;sX=e.touches[0].clientX-camWin.offsetLeft;sY=e.touches[0].clientY-camWin.offsetTop;e.stopPropagation();});
    window.addEventListener('touchmove',e=>{if(isD){camWin.style.left=(e.touches[0].clientX-sX)+'px';camWin.style.top=(e.touches[0].clientY-sY)+'px';}});
    window.addEventListener('touchend',()=>isD=false);

    animate();
  </script>
</body>
</html>
